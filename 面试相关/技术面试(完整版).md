#### 1.谈谈你对ES6的理解

> - 箭头函数(https://www.jianshu.com/p/a416cb02e4a2)
>   - 箭头函数是es6当中对函数的一种全新表示法。其将函数的简洁性发扬到了极致.如果只有一条语句，可以将{}和return省略掉,如果语句为多条，则不可以省略{}和return
> - 模板字符串
> - 解构赋值
> - let const
> - promise

#### 2.谈谈你对面向对象的理解(封装,继承,多态)

> 1. 原型
>    - 原型的理解：
>
>      - 每个函数都会默认有一个prototype属性，它是一个指针，指向此函数的原型对象。而构造函数作为一个函数，同样拥有自己的原型对象，而通过构造函数生成的对象实例中，拥有一个_proto_ 属性，它指向构造函数的原型对象，我们把构造函数的原型对象称为对象实例的原型
>
>    - 原型链:
>
>      - 既然每个实例对象都有一个原型，而每个构造函数也都能创建实例，那假如我们将构造函数 f1 的原型属性指向构造函数f2的实例对象，那么构造函数f1的实例对象就能访问f2的原型属性，依次类推，我们还可以把构造函数f3的原型属性指向f2的队实例对象，那么f3的实例对象同样可以访问到f1的原型，这样，就构成了一条原型链。
> 2. 继承
>    - 原型继承:原型链是实现原型继承的主要方法，基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。
>
>      ​	缺点:无法设置构造函数的参数
>    - 拷贝继承:for in 拷贝继承(把一个对象中的属性或者方法直接复制到另一个对象中)
> 3. 闭包
>    - 闭包的原理:全局作用域访问局部作用域中变量的现象叫闭包
>    - 在工作中那个地方使用到了闭包:
>    - 引起的内存泄露问题
>      - 不是以函数控制的定时器
>      - 打印日志
>      - for循环
>      - 闭包
> 4. 深拷贝:如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响
> 5. 浅拷贝:也可称为对象继承,复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响
> 6. 递归:自己调用自己,一般都要写一个结束的条件
>    运行顺序:往后找,结果往前传

#### 3.常用的数组的方法

> (1) 数组去重
>
> (2) Foreach
>
> (3) Map: 对数组中每个元素执行一次给定函数，原数组不变，返回新数组
>
> (4) Filter: 是对数组中每个元素执行一次给定函数，原数组不变，返回符合条件的新数组
>
> (5) Reduce: 是第一个参数是一个函数，该函数的参数为上一次执行函数结果pre和目前元素的值和索引，通常用于求数组之和，第二个参数是在第一次执行函数是的pre的值，如果没有该参数则将第一个值当做pre的值
>
> (6) Every: 是对数组中每个元素执行一次给定函数，如果有一个结果为false，则返回false；
>
> (7) Some: 与every相对，是对数组中每个元素执行一次给定函数，如果有一个结果为true，则返回true；

#### 4.常用字符串的方法

> (1)  puts函数（字符串输出函数）
>
> (2) gets函数（字符串输入函数
>
> (3) strcat（字符串连接函数）:把两个字符数组中的字符串连接起来（字符串1在前，字符串2在后）。结果放在字符数组1中。
>
> (4) strcpy，strncpy(字符串复制函数):
>
> ​	1) strncpy（字符数组1，字符串2，n（字符个数））
>
> ​	2) strcpy（字符数组1，字符串2）
>
> (5) strcmp(字符串1，字符串2)字符串比较函数:比较字符的ASCII码,相等返回0,大于返回正整数,小于返回负整数.
>
> (6) strlen（字符数组）:测量字符串的实际长度。（不包括'\0'）
>
> (7) strlwr（转化为小写的函数）:作用：将字符串中的大写字母转化为小写。
>
> (8) strupr（转化为大写的函数）:将字符串中的小写字母转化为大写字母。

#### 5.数组去重的方法列举3种

> \1. 双重for循环去重
>
> 原理:两两比较如果相等的话就删除第二个 
>
> 例如: 1 1 1 3 2 1 2 4 
>
> 先让第一个1 即arr[0]与后面的一个个比较 如果后面的值等于arr[0] 删除后面的值 ,第一次结束后的结果是 1 3 2 2 4 删除了后面所有的1 ,同理 第二次 第三会删除与自己相同的元素
>
>  
>
> \2. 单层for循环
>
>  
>
> function norepeat(arr){
>
> ​                arr.sort();
>
> ​                //先排序让大概相同的在一个位置，这里为什么说是大概相同 是因为sort排序是把元素当字符串排序的 它和可能排成 1 1 10 11 2 20 3 ... 不是我们想要的从小到大
>
> for(var i = 0; i < arr.length-1;i++){
>
> ​        //还是两两比较 一样删除后面的
>
> ​                    if(arr[i]==arr[i+1]){
>
> ​                        arr.splice(i,1);
>
> ​                        //i-- 和j--同理
>
> ​                        i--;
>
> ​                    }
>
> ​                }
>
> ​                return arr;
>
> ​            }
>
> \3. 利用对象的思想 如果对象里没有这个属性的话就会返回undefined 
> ​     用这个原理当返回的是undefined时 让其放入数组 然后在给这个属性赋值
>
> \4. 循环比较如果相等的让后面的元素值为0 最后在输出的时候删除为0的 这个前提是你的数据里不能有0 但是凡事可以变通你可以设置任何值替代这个0 这个方法是我当时想到实现的所以没有进行很好的优化(了解)
>
> \5. 利用 indexOf 属性 indexOf是返回某个指定的字符在字符串中出现的位置，如果没有就会返回,因此我们可以很好的利用这个属性 当返回的是 -1时 就让其存入数组
>
>  
>
> function noRepeat2(arr){
>
> ​        var newArr = [];
>
> ​        for(var i = 0; i < arr.length; i++){
>
> ​            if(newArr.indexOf(arr[i]) == -1){
>
> ​                        newArr.push(arr[i]);
>
> ​                }
>
> ​        }
>
> ​        return newArr;
>
> ​    }
>
> 

#### 6.数组排序的方法列举3钟

> 1. 冒泡排序(两两相比,按照从小到大或者从大到小的顺序进行交换)
> 2. 交换排序(将第一个位置的数拿出来,依次和后面的数进行比较,若比后面的数大,则交换位置,再拿出第二个数和第三个数比较,依次类推)
> 3. 顺序排序(先找到数组中最小或最大的,存放起来,再在剩下的数组中找出最小或最大的依次类推,直到找到最后一个位置)

#### 7.盒子在页面居中显示

> 1. margin: 0 auto;
> 2. 定位加margin
> 3. flex布局:display：flex
>    ​          justify-content：center
>    ​          align-items：center
> 4. 定位加C3(top:50%;left:50%;transform:translate(-50%,-50%);)

#### 8.谈谈你对ajax的理解

> 用途:js向服务器请求数据,实现异步请求,局部刷新
>
> 原理:html的主线程一直不停的在跑,需要后台的数据的时候不用重新去生成一个html,js中直接生成一个异步对象,让这对象去发送请求和接收响应

#### 9.清除浮动的几种方法

> 1、父级div定义伪类：after和zoom
>
> 2.在结尾处添加空div标签clear:both
>
> 4.父级div定义overflow:hidden
>
> **不推荐使用:**
>
> 3.父级div定义height
>
> 5.父级div定义overflow:auto
>
> 6.父级div也一起浮动
>
> 7.父级div定义display:table
>
> 8.结尾处加br标签clear:both

#### 10.谈谈你对js的执行机制的理解(event queue 事件队列   					     event table:事件表)

> 1. js是单线程语言
> 2. 首先判断js是同 步还是异步,同步就进入主线程,异步就进入event table, 异步任务在event table中注册函数,当满足触发条件后,被推入事件队列中,同步任务进入主线程后一直执行,直到主线程空闲时,才会去事件队列中查看是否有可执行的异步任务,如果有就推入主线程中

#### 11.什么是垃圾回收机制

> 工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
>
> 工作流程：
>
> - 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；
>
> - 去掉环境中的变量以及被环境中的变量引用的变量的标记；
>
> - 被加上标记的会被视为准备删除的变量；
>
> - 垃圾回收器完成内存清理工作，销毁那些带标记的值并回收他们所占用的内存空间。

#### 12.谈谈你对cookie、sessionStorage、localStorage理解

> sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
>
> web storage和cookie的区别
>
> Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。
>
> 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。

#### 13.谈谈get请求与post请求的理解

> 1. get请求:主要用于获取数据,get请求能够被缓存,会保存在浏览器的浏览记录,请求的URL能够保存为浏览器书签,有长度限制,
> 2. post请求:post请求不能被缓存下来,请求不会保留在浏览器记录中,URL无法保存为浏览器书签,没有长度限制(请求参数放在请求body)

#### 14.谈谈你对跨域的理解

> 1. 什么是跨域
>
>    域名不同,端口不同,协议不同,浏览器对于JavaScript的同源策略的限制,所以就有了跨域
>
> 2. 解决跨域的几种方式
>
>    - jsonp:基本原理就是通过动态创建script标签，然后利用src属性进行跨域.
>
>    - cors:是在 es5 之后提出的跨域方案. 只需要在服务器配置一个跨域响应头接口
>
>    - **正向代理：** 我借助于我的服务器, 像数据服务器发送数据, 我的服务器只需要向数据服务器发送get请求即可
>
>      **反向代理：** 与正向代理类似, 但是不借助于脚本, 而是直接使用 服务器映射 url.
>

##### 15.vue中v-show与v-if的区别

> xxxxx

#### 16.vue的生命周期函数

> 1. xxx
> 2. xxx
> 3. xxx
> 4. xxx
> 5. xxx
> 6. xxx
> 7. xxx
> 8. xxx

#### 17.vue中vue-router中的导航守卫

> xxxx

#### 18.vue中vuex如何存储公共数据

> x'x'x'x'x'x

#### 19.谈谈你对token的理解

> xxxx

#### 20.在实际开发过程中你是怎么解决问题的

> 这是就要求我们必须冷静对待

#### 21.如何做好前端性能优化

> 网页内容:减少http请求次数
>
> 服务器:Gzip压缩传输文件
>
> 图片:优化图像,优化CSS Sprite,可以尝试使用精灵图
>
> 移动客户端:保持单个内容小于25KB,[打包组建成复合文档
>
> 

#### 22.谈谈你对webpack的理解

> xxxxx